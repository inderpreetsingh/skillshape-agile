{"version":3,"sources":["meteor://ðŸ’»app/packages/simple_reactive-method/packages/simple_reactive-method.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/simple_reactive-method.js","sourcesContent":["(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                         //\n// packages/simple:reactive-method/reactive-method.js                                      //\n//                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                           //\nReactiveMethod = {                                                                         // 1\n  /**                                                                                      // 2\n   * A global object that matches serialized arguments of Method.apply to an               // 3\n   * array of computations that depend on the result of that method. Used mainly           // 4\n   * to allow invalidation of method results from outside of the computation               // 5\n   * using that result.                                                                    // 6\n   * @type {Object}                                                                        // 7\n   */                                                                                      // 8\n  _computations: {},                                                                       // 9\n                                                                                           // 10\n  /**                                                                                      // 11\n   * Call a Meteor method. Can only be used inside a Tracker autorun (which                // 12\n   * includes Blaze helpers). Functions much like a promise - on the first run             // 13\n   * of the computation returns undefined, and when the method result comes back           // 14\n   * reruns the computation and returns the actual result. If this method is               // 15\n   * called in consecutive reruns of the computation with the same arguments, it           // 16\n   * remembers the previous result, which avoids calling the method over and               // 17\n   * over again forever.                                                                   // 18\n   *                                                                                       // 19\n   * Watch out - if you call this method with a constantly changing value as one           // 20\n   * of the arguments (for example the current time or a random value) it will             // 21\n   * never return anything.                                                                // 22\n   *                                                                                       // 23\n   * The API for the arguments is exactly the same as Meteor.call.                         // 24\n   *                                                                                       // 25\n   * @param {String} methodName The name of the method to call                             // 26\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments                           // 27\n   */                                                                                      // 28\n  call: function (methodName /*, ...arguments */) {                                        // 29\n    if (! Tracker.currentComputation) {                                                    // 30\n      // If not in an autorun, throw error                                                 // 31\n      throw new Error(\"Don't use ReactiveMethod.call outside of a Tracker computation.\");  // 32\n    }                                                                                      // 33\n                                                                                           // 34\n    var args = _.toArray(arguments);                                                       // 35\n    return ReactiveMethod.apply(methodName, _.rest(args));                                 // 36\n  },                                                                                       // 37\n                                                                                           // 38\n  /**                                                                                      // 39\n   * Just like ReactiveMethod.call except uses the calling API of Meteor.apply             // 40\n   * instead of Meteor.call.                                                               // 41\n   * @param  {[type]} methodName [description]                                             // 42\n   * @param  {[type]} methodArgs [description]                                             // 43\n   * @return {[type]}            [description]                                             // 44\n   */                                                                                      // 45\n  apply: function (methodName, methodArgs) {                                               // 46\n    var cc = Tracker.currentComputation;                                                   // 47\n                                                                                           // 48\n    if (! cc) {                                                                            // 49\n      // If not in an autorun, throw error                                                 // 50\n      throw new Error(\"Don't use ReactiveMethod.apply outside of a Tracker computation.\"); // 51\n    }                                                                                      // 52\n                                                                                           // 53\n    var serializedArgs = EJSON.stringify([methodName, methodArgs]);                        // 54\n                                                                                           // 55\n                                                                                           // 56\n    cc._reactiveMethodData = cc._reactiveMethodData || {};                                 // 57\n    cc._reactiveMethodStale = cc._reactiveMethodStale || {};                               // 58\n                                                                                           // 59\n    var methodReturnValue;                                                                 // 60\n                                                                                           // 61\n    if (cc._reactiveMethodData && _.has(cc._reactiveMethodData, serializedArgs)) {         // 62\n      // We are calling the method again with the same arguments, return the               // 63\n      // previous result                                                                   // 64\n                                                                                           // 65\n      // Mark this result as used                                                          // 66\n      delete cc._reactiveMethodStale[serializedArgs];                                      // 67\n      methodReturnValue = cc._reactiveMethodData[serializedArgs];                          // 68\n    } else {                                                                               // 69\n      // Only record the method call if it doesn't match the condition above about         // 70\n      // being called again with the same arguments                                        // 71\n      recordMethodComputation(cc, serializedArgs);                                         // 72\n                                                                                           // 73\n      Meteor.apply(methodName, methodArgs, function (err, result) {                        // 74\n        cc._reactiveMethodData[serializedArgs] = result;                                   // 75\n        cc.invalidate();                                                                   // 76\n      });                                                                                  // 77\n    }                                                                                      // 78\n                                                                                           // 79\n    // Copied logic from meteor/meteor/packages/ddp/livedata_connection.js                 // 80\n    cc.onInvalidate(function () {                                                          // 81\n      // Make sure this is used                                                            // 82\n      cc._reactiveMethodStale[serializedArgs] = true;                                      // 83\n                                                                                           // 84\n      Tracker.afterFlush(function () {                                                     // 85\n        if (cc._reactiveMethodStale[serializedArgs]) {                                     // 86\n          delete cc._reactiveMethodData[serializedArgs];                                   // 87\n          delete cc._reactiveMethodStale[serializedArgs];                                  // 88\n          deleteMethodComputation(cc, serializedArgs);                                     // 89\n        }                                                                                  // 90\n      });                                                                                  // 91\n    });                                                                                    // 92\n                                                                                           // 93\n    cc.onInvalidate(function () {                                                          // 94\n      if (cc.stopped) {                                                                    // 95\n        // Delete this computation from global computation store to avoid                  // 96\n        // keeping a reference to every computation ever                                   // 97\n        cleanUpComputation(cc);                                                            // 98\n      }                                                                                    // 99\n    });                                                                                    // 100\n                                                                                           // 101\n    return methodReturnValue;                                                              // 102\n  },                                                                                       // 103\n                                                                                           // 104\n  /**                                                                                      // 105\n   * Invalidate all computations that are currently depending on the result                // 106\n   * of a particular ReactiveMethod.call.                                                  // 107\n   */                                                                                      // 108\n  invalidateCall: function (methodName /*, ...arguments */) {                              // 109\n    var args = _.toArray(arguments);                                                       // 110\n    ReactiveMethod.invalidateApply(methodName, _.rest(args));                              // 111\n  },                                                                                       // 112\n                                                                                           // 113\n  /**                                                                                      // 114\n   * Invalidate all computations that are currently depending on the result of             // 115\n   * a particular ReactiveMethod.apply.                                                    // 116\n   */                                                                                      // 117\n  invalidateApply: function (methodName, methodArgs) {                                     // 118\n    var serializedArgs = EJSON.stringify([methodName, methodArgs]);                        // 119\n                                                                                           // 120\n    _.each(ReactiveMethod._computations[serializedArgs], function (cc) {                   // 121\n      delete cc._reactiveMethodData[serializedArgs];                                       // 122\n      cc.invalidate();                                                                     // 123\n    });                                                                                    // 124\n  }                                                                                        // 125\n};                                                                                         // 126\n                                                                                           // 127\n/**                                                                                        // 128\n * Record that a computation is using the result of a method call, to allow                // 129\n * invalidation from outside of the computation                                            // 130\n * @param  {String} serializedArgs Arguments to Method.apply, in serialized form           // 131\n */                                                                                        // 132\nfunction recordMethodComputation(computation, serializedArgs) {                            // 133\n  // Add computation to the list of computations using these arguments, and                // 134\n  // create the array if it doesn't exist.                                                 // 135\n  var initial = ReactiveMethod._computations[serializedArgs] || [];                        // 136\n  ReactiveMethod._computations[serializedArgs] =                                           // 137\n    _.union(initial, [computation]);                                                       // 138\n}                                                                                          // 139\n                                                                                           // 140\n/**                                                                                        // 141\n * Remove the computation from the global dictionary of which computations are             // 142\n * watching which method results                                                           // 143\n * @param  {Tracker.Computation} computation                                               // 144\n * @param  {String} serializedArgs Arguments to Method.apply, in serialized form           // 145\n */                                                                                        // 146\nfunction deleteMethodComputation(computation, serializedArgs) {                            // 147\n  var methodsForArgs = ReactiveMethod._computations[serializedArgs];                       // 148\n  var withoutCC = _.without(methodsForArgs, computation);                                  // 149\n                                                                                           // 150\n  if (withoutCC.length > 0) {                                                              // 151\n    // Remove computation from the array                                                   // 152\n    ReactiveMethod._computations[serializedArgs] = withoutCC;                              // 153\n  } else {                                                                                 // 154\n    // Delete the array if it is empty to avoid memory leak                                // 155\n    delete ReactiveMethod._computations[serializedArgs];                                   // 156\n  }                                                                                        // 157\n}                                                                                          // 158\n                                                                                           // 159\n/**                                                                                        // 160\n * Remove all references to the computation from global cache of computations,             // 161\n * used to avoid memory leaks from storing stopped computations                            // 162\n * @param  {Tracker.Computation} computation                                               // 163\n */                                                                                        // 164\nfunction cleanUpComputation(computation) {                                                 // 165\n  _.each(computation._reactiveMethodData, function (data, serializedArgs) {                // 166\n    deleteMethodComputation(computation, serializedArgs);                                  // 167\n  });                                                                                      // 168\n}                                                                                          // 169\n                                                                                           // 170\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}